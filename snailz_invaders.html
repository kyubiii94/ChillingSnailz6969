<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SNAILZ INVADERS ‚Äî Lettuce Island Arcade</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Syne:wght@400;700;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
/* ===========================
   VARIABLES & RESET (matching main site)
=========================== */
:root {
  --void: #03040a;
  --deep: #080c18;
  --surface: #0f1628;
  --raised: #162035;
  --aqua: #00d4ff;
  --aqua-dim: rgba(0,212,255,0.15);
  --aqua-glow: 0 0 20px rgba(0,212,255,0.5), 0 0 60px rgba(0,212,255,0.2);
  --magma: #ff4500;
  --magma-dim: rgba(255,69,0,0.15);
  --magma-glow: 0 0 20px rgba(255,69,0,0.5), 0 0 60px rgba(255,69,0,0.2);
  --wizard: #a855f7;
  --wizard-dim: rgba(168,85,247,0.15);
  --wizard-glow: 0 0 20px rgba(168,85,247,0.5), 0 0 60px rgba(168,85,247,0.2);
  --chill: #39ff14;
  --chill-dim: rgba(57,255,20,0.15);
  --chill-glow: 0 0 20px rgba(57,255,20,0.5), 0 0 60px rgba(57,255,20,0.2);
  --gold: #ffd700;
  --white: #e8ecf5;
  --muted: #6b7a9b;
  --border: rgba(255,255,255,0.07);
  --font-pixel: 'Press Start 2P', monospace;
  --font-display: 'Syne', sans-serif;
  --font-mono: 'JetBrains Mono', monospace;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { overflow-x: hidden; }
body {
  background: var(--void);
  color: var(--white);
  font-family: var(--font-mono);
  overflow-x: hidden;
  line-height: 1.6;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* Scanlines overlay */
body::before {
  content:''; position:fixed; inset:0; z-index:9990; pointer-events:none;
  background: repeating-linear-gradient(0deg,transparent,transparent 3px,rgba(0,0,0,0.06) 3px,rgba(0,0,0,0.06) 4px);
}

/* ===========================
   ANIMATIONS
=========================== */
@keyframes blink { 0%,100% { opacity:1; } 50% { opacity:0; } }
@keyframes pulse { 0%,100% { opacity:1; } 50% { opacity:0.6; } }
@keyframes flicker { 0%,18%,22%,25%,53%,57%,100% { opacity:1; } 20%,24%,55% { opacity:0.5; } }
@keyframes scan { 0% { transform:translateY(-100%); opacity:0.5; } 100% { transform:translateY(200vh); opacity:0; } }
@keyframes float { 0%,100% { transform:translateY(0); } 50% { transform:translateY(-8px); } }
@keyframes shimmer { 0% { background-position:-200% 0; } 100% { background-position:200% 0; } }
@keyframes slideUp { from { opacity:0; transform:translateY(30px); } to { opacity:1; transform:translateY(0); } }
@keyframes fadeIn { from { opacity:0; } to { opacity:1; } }
@keyframes shake { 0%,100% { transform:translateX(0); } 10%,30%,50%,70%,90% { transform:translateX(-4px); } 20%,40%,60%,80% { transform:translateX(4px); } }
@keyframes explode {
  0% { transform:scale(1); opacity:1; }
  50% { transform:scale(1.8); opacity:0.6; }
  100% { transform:scale(0); opacity:0; }
}
@keyframes waveIn {
  from { opacity:0; transform:translateY(-40px) scale(0.8); }
  to { opacity:1; transform:translateY(0) scale(1); }
}

/* ===========================
   BACKGROUND
=========================== */
.game-bg {
  position: fixed; inset: 0; z-index: 0;
  background:
    radial-gradient(ellipse 60% 50% at 20% 30%, rgba(0,212,255,0.04) 0%, transparent 65%),
    radial-gradient(ellipse 50% 50% at 80% 70%, rgba(255,69,0,0.03) 0%, transparent 60%),
    radial-gradient(ellipse 40% 40% at 50% 50%, rgba(57,255,20,0.03) 0%, transparent 55%),
    var(--void);
}
.game-grid-bg {
  position: fixed; inset: 0; z-index: 0;
  background-image:
    linear-gradient(rgba(57,255,20,0.015) 1px, transparent 1px),
    linear-gradient(90deg, rgba(57,255,20,0.015) 1px, transparent 1px);
  background-size: 48px 48px;
}
.game-scan {
  position: fixed; left:0; right:0; height:1px;
  background: linear-gradient(90deg, transparent 0%, rgba(57,255,20,0.3) 50%, transparent 100%);
  animation: scan 6s linear infinite;
  z-index: 1;
}

/* ===========================
   NAVBAR
=========================== */
.game-nav {
  position: fixed; top: 0; left: 0; right: 0; z-index: 1000;
  height: 56px; display: flex; align-items: center; justify-content: space-between;
  padding: 0 24px;
  background: rgba(3,4,10,0.9);
  backdrop-filter: blur(24px);
  border-bottom: 1px solid var(--border);
}
.nav-left {
  display: flex; align-items: center; gap: 16px;
}
.back-btn {
  font-family: var(--font-pixel); font-size: 7px; letter-spacing: 1px;
  color: var(--muted); text-decoration: none; padding: 6px 12px;
  border: 1px solid var(--border); transition: all 0.2s;
  display: flex; align-items: center; gap: 8px;
}
.back-btn:hover { color: var(--aqua); border-color: rgba(0,212,255,0.3); }
.nav-title {
  font-family: var(--font-pixel); font-size: 9px; letter-spacing: 2px;
  color: var(--chill); text-shadow: 0 0 12px rgba(57,255,20,0.5);
  animation: flicker 8s infinite;
}
.nav-right-info {
  display: flex; align-items: center; gap: 16px;
}
.nav-faction {
  font-family: var(--font-pixel); font-size: 6px; letter-spacing: 1px;
  padding: 4px 10px; border: 1px solid rgba(0,212,255,0.3);
  color: var(--aqua); background: var(--aqua-dim);
}
.nav-hi-score {
  font-family: var(--font-pixel); font-size: 7px; color: var(--gold);
  text-shadow: 0 0 8px rgba(255,215,0,0.4);
}

/* ===========================
   MAIN CONTAINER
=========================== */
.game-wrapper {
  position: relative; z-index: 2;
  flex: 1; display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  padding: 72px 20px 20px;
  gap: 16px;
}

/* ===========================
   HUD (Score bar)
=========================== */
.hud {
  display: flex; align-items: center; justify-content: space-between;
  width: 100%; max-width: 720px;
  padding: 10px 20px;
  background: var(--surface);
  border: 1px solid var(--border);
  clip-path: polygon(0 0,calc(100% - 8px) 0,100% 8px,100% 100%,8px 100%,0 calc(100% - 8px));
}
.hud-block {
  text-align: center;
}
.hud-label {
  font-family: var(--font-pixel); font-size: 6px; letter-spacing: 2px;
  color: var(--muted); margin-bottom: 2px;
}
.hud-val {
  font-family: var(--font-pixel); font-size: 12px; letter-spacing: 1px;
}
.hud-score { color: var(--chill); text-shadow: var(--chill-glow); }
.hud-lives { color: var(--magma); text-shadow: var(--magma-glow); }
.hud-wave { color: var(--aqua); text-shadow: var(--aqua-glow); }
.hud-combo { color: var(--wizard); text-shadow: var(--wizard-glow); }

/* ===========================
   CANVAS FRAME
=========================== */
.canvas-frame {
  position: relative;
  background: var(--surface);
  border: 2px solid rgba(57,255,20,0.2);
  box-shadow: 0 0 60px rgba(57,255,20,0.08), inset 0 0 60px rgba(0,0,0,0.5);
  clip-path: polygon(0 0,calc(100% - 12px) 0,100% 12px,100% 100%,12px 100%,0 calc(100% - 12px));
  overflow: hidden;
}
.canvas-frame::before {
  content:''; position:absolute; inset:0; z-index:2; pointer-events:none;
  background: repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(57,255,20,0.015) 2px,rgba(57,255,20,0.015) 4px);
}
.canvas-frame::after {
  content:''; position:absolute; top:0; left:0; right:0; height:1px; z-index:3;
  background: linear-gradient(90deg, transparent, var(--chill), var(--aqua), transparent);
  opacity: 0.5;
}
#gameCanvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

/* ===========================
   CONTROLS INFO BAR
=========================== */
.controls-bar {
  display: flex; align-items: center; justify-content: center; gap: 24px;
  width: 100%; max-width: 720px;
  padding: 8px 16px;
  background: rgba(15,22,40,0.6);
  border: 1px solid var(--border);
}
.ctrl-hint {
  font-family: var(--font-pixel); font-size: 6px; letter-spacing: 1px;
  color: var(--muted); display: flex; align-items: center; gap: 6px;
}
.key-badge {
  display: inline-flex; align-items: center; justify-content: center;
  min-width: 22px; height: 18px; padding: 0 4px;
  background: var(--raised);
  border: 1px solid rgba(57,255,20,0.2);
  font-family: var(--font-pixel); font-size: 6px;
  color: var(--chill);
}

/* ===========================
   OVERLAY SCREENS
=========================== */
.overlay {
  position: absolute; inset: 0; z-index: 10;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  background: rgba(3,4,10,0.92);
  backdrop-filter: blur(6px);
  text-align: center;
  gap: 20px;
  padding: 40px;
}
.overlay.hidden { display: none; }

.overlay-title {
  font-family: var(--font-display); font-weight: 800;
  font-size: clamp(28px, 5vw, 48px); line-height: 1.1;
  animation: slideUp 0.6s ease-out;
}
.overlay-title .accent { color: var(--chill); text-shadow: var(--chill-glow); }
.overlay-title .aqua { color: var(--aqua); text-shadow: var(--aqua-glow); }

.overlay-sub {
  font-family: var(--font-pixel); font-size: 8px; letter-spacing: 2px;
  color: var(--muted); max-width: 380px; line-height: 2;
  animation: slideUp 0.6s ease-out 0.1s both;
}

.overlay-art {
  font-size: 56px; animation: float 3s ease-in-out infinite;
  filter: drop-shadow(0 0 20px rgba(57,255,20,0.4));
}

/* Faction selector */
.faction-select {
  display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
  animation: slideUp 0.6s ease-out 0.2s both;
}
.faction-btn {
  display: flex; flex-direction: column; align-items: center; gap: 6px;
  padding: 14px 10px;
  background: var(--surface);
  border: 2px solid var(--border);
  color: var(--white);
  cursor: pointer; transition: all 0.2s;
  font-family: var(--font-pixel); font-size: 6px; letter-spacing: 1px;
}
.faction-btn .f-icon { font-size: 28px; transition: transform 0.3s; }
.faction-btn:hover .f-icon { transform: scale(1.2); }
.faction-btn[data-faction="aqua"]:hover,
.faction-btn[data-faction="aqua"].selected {
  border-color: var(--aqua); background: var(--aqua-dim);
  box-shadow: 0 0 20px rgba(0,212,255,0.2); color: var(--aqua);
}
.faction-btn[data-faction="magma"]:hover,
.faction-btn[data-faction="magma"].selected {
  border-color: var(--magma); background: var(--magma-dim);
  box-shadow: 0 0 20px rgba(255,69,0,0.2); color: var(--magma);
}
.faction-btn[data-faction="wizard"]:hover,
.faction-btn[data-faction="wizard"].selected {
  border-color: var(--wizard); background: var(--wizard-dim);
  box-shadow: 0 0 20px rgba(168,85,247,0.2); color: var(--wizard);
}
.faction-btn[data-faction="chill"]:hover,
.faction-btn[data-faction="chill"].selected {
  border-color: var(--chill); background: var(--chill-dim);
  box-shadow: 0 0 20px rgba(57,255,20,0.2); color: var(--chill);
}

.start-game-btn {
  font-family: var(--font-pixel); font-size: 10px; letter-spacing: 2px;
  padding: 16px 36px;
  background: var(--chill); color: var(--void); border: none;
  cursor: pointer; transition: all 0.2s;
  clip-path: polygon(0 0,calc(100% - 10px) 0,100% 10px,100% 100%,10px 100%,0 calc(100% - 10px));
  animation: slideUp 0.6s ease-out 0.3s both;
}
.start-game-btn:hover {
  background: var(--white); transform: translateY(-3px);
  box-shadow: 0 12px 32px rgba(57,255,20,0.35);
}
.start-game-btn:disabled {
  opacity: 0.3; cursor: not-allowed; transform: none;
  box-shadow: none;
}

.blink-text {
  animation: blink 1.2s infinite;
}

/* Game Over */
.go-score {
  font-family: var(--font-display); font-weight: 800;
  font-size: 56px; color: var(--chill);
  text-shadow: var(--chill-glow);
  animation: slideUp 0.5s ease-out 0.15s both;
}
.go-stats {
  display: flex; gap: 24px;
  animation: slideUp 0.5s ease-out 0.25s both;
}
.go-stat {
  text-align: center;
}
.go-stat-val {
  font-family: var(--font-display); font-weight: 700;
  font-size: 22px; color: var(--aqua);
}
.go-stat-lbl {
  font-family: var(--font-pixel); font-size: 6px;
  color: var(--muted); letter-spacing: 1px; margin-top: 2px;
}
.new-record {
  font-family: var(--font-pixel); font-size: 8px;
  color: var(--gold); text-shadow: 0 0 12px rgba(255,215,0,0.5);
  animation: blink 0.8s infinite;
}

/* Pause */
.pause-options {
  display: flex; gap: 12px;
  animation: slideUp 0.4s ease-out 0.1s both;
}
.pause-btn {
  font-family: var(--font-pixel); font-size: 8px; letter-spacing: 1px;
  padding: 12px 20px; cursor: pointer; transition: all 0.2s;
  border: 1px solid var(--border); background: var(--surface); color: var(--white);
}
.pause-btn:hover { border-color: var(--aqua); color: var(--aqua); }
.pause-btn.primary { background: var(--chill); color: var(--void); border-color: var(--chill); }
.pause-btn.primary:hover { background: var(--white); }

/* ===========================
   POWER-UP INDICATOR
=========================== */
.powerup-bar {
  position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%);
  z-index: 5; display: flex; gap: 6px;
}
.pu-icon {
  width: 28px; height: 28px;
  background: var(--surface);
  border: 1px solid var(--border);
  display: flex; align-items: center; justify-content: center;
  font-size: 14px; opacity: 0.3; transition: all 0.3s;
  position: relative;
}
.pu-icon.active {
  opacity: 1; border-color: var(--gold);
  box-shadow: 0 0 12px rgba(255,215,0,0.3);
}
.pu-timer {
  position: absolute; bottom: -2px; left: 0; right: 0; height: 2px;
  background: var(--gold);
  transform-origin: left;
  transition: transform 0.1s linear;
}

/* ===========================
   TOUCH BUTTONS (shared)
=========================== */
.touch-btn {
  background: rgba(15,22,40,0.9);
  border: 2px solid rgba(57,255,20,0.3);
  color: var(--chill);
  font-size: 24px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer;
  -webkit-user-select: none; user-select: none;
  touch-action: manipulation;
  border-radius: 6px;
  transition: background 0.06s, border-color 0.06s, box-shadow 0.06s;
  -webkit-tap-highlight-color: transparent;
}
.touch-btn:active, .touch-btn.pressed {
  background: var(--chill-dim);
  border-color: var(--chill);
  box-shadow: 0 0 18px rgba(57,255,20,0.35);
  transform: scale(0.93);
}
.touch-fire {
  border-radius: 50%;
  background: rgba(255,69,0,0.12);
  border: 2px solid rgba(255,69,0,0.45);
  color: var(--magma);
  font-family: var(--font-pixel); font-size: 8px; letter-spacing: 1px;
}
.touch-fire:active, .touch-fire.pressed {
  background: rgba(255,69,0,0.28);
  border-color: var(--magma);
  box-shadow: 0 0 22px rgba(255,69,0,0.45);
}
.touch-special {
  border-radius: 50%;
  background: rgba(168,85,247,0.1);
  border: 2px solid rgba(168,85,247,0.35);
  color: var(--wizard);
}
.touch-special:active, .touch-special.pressed {
  background: var(--wizard-dim);
  border-color: var(--wizard);
  box-shadow: 0 0 18px rgba(168,85,247,0.4);
}
.touch-pause {
  border-radius: 4px;
  border-color: rgba(255,255,255,0.12);
  color: var(--muted);
}
.touch-pause:active { border-color: var(--aqua); color: var(--aqua); }

/* ===========================
   PORTRAIT TOUCH BAR (below canvas)
=========================== */
.touch-controls {
  display: none;
  width: 100%; max-width: 720px;
  padding: 8px 14px;
  justify-content: space-between;
  align-items: center;
  background: rgba(8,12,24,0.85);
  border-top: 1px solid var(--border);
  gap: 8px;
  flex-shrink: 0;
}
.touch-dpad { display: flex; gap: 8px; align-items: center; }
.touch-action-group { display: flex; gap: 10px; align-items: center; }
.touch-controls .touch-btn { width: 62px; height: 62px; }
.touch-controls .touch-fire { width: 76px; height: 76px; }
.touch-controls .touch-special { width: 56px; height: 56px; font-size: 20px; }
.touch-controls .touch-pause { width: 44px; height: 44px; font-size: 18px; }

/* ===========================
   LANDSCAPE SIDE PANELS
=========================== */
.game-area {
  /* Transparent wrapper in portrait ‚Äî children flow directly */
  display: contents;
}
.touch-panel-left,
.touch-panel-right {
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: flex-end;
  padding: 10px 8px 14px;
  gap: 12px;
  background: rgba(8,12,24,0.8);
  border-top: 1px solid var(--border);
  flex-shrink: 0;
  width: 86px;
}
.touch-panel-left  { border-right: 1px solid var(--border); }
.touch-panel-right { border-left:  1px solid var(--border); }
.touch-panel-left  .touch-btn { width: 64px; height: 64px; font-size: 26px; }
.touch-panel-right .touch-btn { width: 64px; height: 64px; font-size: 26px; }
.touch-panel-right .touch-fire    { width: 72px; height: 72px; font-size: 8px; }
.touch-panel-right .touch-special { width: 60px; height: 60px; font-size: 22px; }
.touch-panel-left  .touch-pause   { width: 42px; height: 42px; font-size: 16px; margin-bottom: auto; margin-top: 2px; }

/* ===========================
   PORTRAIT OVERLAY (rotate hint)
=========================== */
.portrait-overlay {
  display: none;
  position: fixed; inset: 0; z-index: 9999;
  background: rgba(3,4,10,0.97);
  backdrop-filter: blur(8px);
  flex-direction: column;
  align-items: center; justify-content: center;
  gap: 28px; text-align: center; padding: 40px;
  pointer-events: all;
}
.portrait-overlay.active { display: flex; }
.portrait-phone {
  font-size: 72px;
  display: inline-block;
  animation: rotate-hint 2.8s ease-in-out infinite;
  filter: drop-shadow(0 0 24px rgba(57,255,20,0.5));
}
@keyframes rotate-hint {
  0%,25%   { transform: rotate(0deg); }
  55%,85%  { transform: rotate(90deg); }
  100%     { transform: rotate(0deg); }
}
.portrait-title {
  font-family: var(--font-pixel); font-size: 9px;
  letter-spacing: 2px; color: var(--chill);
  text-shadow: var(--chill-glow);
  animation: pulse 2s infinite;
}
.portrait-sub {
  font-family: var(--font-mono); font-size: 14px;
  color: var(--muted); line-height: 1.7; max-width: 260px;
}
.portrait-hint {
  font-family: var(--font-pixel); font-size: 6px;
  color: rgba(255,255,255,0.2); letter-spacing: 1px;
}

/* ===========================
   POINTER: COARSE (touch devices)
=========================== */
@media (pointer: coarse) {
  #gameCanvas { touch-action: none; }
  body { overscroll-behavior: none; }
}

/* ===========================
   PORTRAIT MOBILE
=========================== */
@media (max-width: 768px) and (orientation: portrait) {
  .touch-controls { display: flex; }
  .controls-bar   { display: none; }
  .game-wrapper   { padding: 64px 8px 8px; gap: 8px; }
  .hud            { padding: 7px 12px; }
  .game-nav       { padding: 0 12px; }
  .nav-title      { font-size: 7px; letter-spacing: 1px; }
  .back-btn       { font-size: 6px; padding: 5px 8px; gap: 4px; }
  .nav-hi-score   { font-size: 6px; }
  .nav-faction    { font-size: 5px; padding: 3px 6px; }
}
@media (max-width: 480px) and (orientation: portrait) {
  .hud { padding: 5px 8px; gap: 0; }
  .hud-val   { font-size: 9px; }
  .hud-label { font-size: 5px; letter-spacing: 1px; }
  .hud-block { padding: 0 4px; }
  .overlay      { padding: 20px 16px; gap: 14px; }
  .overlay-title { font-size: clamp(22px, 7vw, 38px); }
  .overlay-sub   { font-size: 7px; letter-spacing: 1px; line-height: 1.8; }
  .go-score  { font-size: 40px; }
  .go-stats  { gap: 14px; flex-wrap: wrap; justify-content: center; }
  .faction-select { grid-template-columns: repeat(2, 1fr); gap: 8px; }
  .faction-btn { padding: 12px 8px; font-size: 5px; }
  .faction-btn .f-icon { font-size: 24px; }
  .touch-controls .touch-btn    { width: 54px; height: 54px; font-size: 21px; }
  .touch-controls .touch-fire   { width: 68px; height: 68px; font-size: 7px; }
  .touch-controls .touch-special{ width: 50px; height: 50px; font-size: 17px; }
  .touch-controls .touch-pause  { width: 38px; height: 38px; font-size: 14px; }
  .nav-title { display: none; }
}

/* ===========================
   LANDSCAPE MOBILE (full layout)
=========================== */
@media (orientation: landscape) and (max-height: 540px) and (pointer: coarse) {
  html, body { height: 100%; overflow: hidden; }

  /* Slim navbar */
  .game-nav     { height: 40px; padding: 0 10px; }
  .nav-title    { display: none; }
  .back-btn     { font-size: 6px; padding: 4px 8px; }
  .nav-faction  { font-size: 5px; padding: 2px 6px; }
  .nav-hi-score { font-size: 6px; }

  /* Compact HUD strip */
  .hud       { max-width: 100%; padding: 3px 10px; flex-shrink: 0; border-left: none; border-right: none; clip-path: none; }
  .hud-val   { font-size: 9px; }
  .hud-label { font-size: 4px; letter-spacing: 1px; }
  .hud-block { padding: 0 8px; }

  /* Wrapper: column, full viewport */
  .game-wrapper {
    flex-direction: column;
    padding: 40px 0 0 0;
    height: 100vh;
    gap: 3px;
    align-items: stretch;
    justify-content: flex-start;
  }

  /* Game area becomes a row */
  .game-area {
    display: flex;
    flex-direction: row;
    flex: 1;
    min-height: 0;
    align-items: stretch;
  }

  /* Show landscape panels, hide portrait bar */
  .touch-panel-left,
  .touch-panel-right { display: flex; }
  .controls-bar      { display: none !important; }
  .touch-controls    { display: none !important; }

  /* Canvas fills the center */
  .canvas-frame {
    flex: 1;
    min-width: 0;
    clip-path: none;
    border-radius: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  /* Overlays compact in landscape */
  .overlay       { padding: 14px 20px; gap: 10px; }
  .overlay-title { font-size: clamp(16px, 4vw, 26px); }
  .overlay-sub   { font-size: 6px; line-height: 1.7; max-width: 320px; }
  .overlay-art   { font-size: 32px; }
  .go-score      { font-size: 30px; }
  .go-stats      { gap: 14px; }
  .faction-select { grid-template-columns: repeat(4, 1fr); gap: 6px; }
  .faction-btn   { padding: 7px 5px; font-size: 5px; }
  .faction-btn .f-icon { font-size: 18px; }
  .start-game-btn { padding: 10px 22px; font-size: 8px; }
  .pause-options  { gap: 8px; }
  .pause-btn      { padding: 8px 14px; font-size: 7px; }
}
</style>
</head>
<body>

<!-- Background layers -->
<div class="game-bg"></div>
<div class="game-grid-bg"></div>
<div class="game-scan"></div>

<!-- Portrait overlay: invite to rotate -->
<div class="portrait-overlay" id="portraitOverlay">
  <div class="portrait-phone">üì±</div>
  <div class="portrait-title">TOURNE TON T√âL√âPHONE</div>
  <div class="portrait-sub">Le jeu est optimis√© en mode paysage pour une meilleure exp√©rience</div>
  <div class="portrait-hint">‚Üª ROTATE TO LANDSCAPE</div>
</div>

<!-- Navigation -->
<nav class="game-nav">
  <div class="nav-left">
    <a href="index.html" class="back-btn">‚óÑ RETOUR</a>
    <span class="nav-title">SNAILZ INVADERS</span>
  </div>
  <div class="nav-right-info">
    <span class="nav-faction" id="navFaction">AQUA</span>
    <span class="nav-hi-score">HI: <span id="navHiScore">00000</span></span>
  </div>
</nav>

<!-- Game Wrapper -->
<div class="game-wrapper">

  <!-- HUD -->
  <div class="hud">
    <div class="hud-block">
      <div class="hud-label">SCORE</div>
      <div class="hud-val hud-score" id="hudScore">00000</div>
    </div>
    <div class="hud-block">
      <div class="hud-label">VIES</div>
      <div class="hud-val hud-lives" id="hudLives">‚ô•‚ô•‚ô•</div>
    </div>
    <div class="hud-block">
      <div class="hud-label">VAGUE</div>
      <div class="hud-val hud-wave" id="hudWave">01</div>
    </div>
    <div class="hud-block">
      <div class="hud-label">COMBO</div>
      <div class="hud-val hud-combo" id="hudCombo">x1</div>
    </div>
  </div>

  <!-- game-area: transparent in portrait, flex-row in landscape -->
  <div class="game-area">

    <!-- LEFT PANEL ‚Äî landscape only (‚óÑ ‚ñ∫ + pause) -->
    <div class="touch-panel-left" id="touchPanelLeft">
      <button class="touch-btn touch-pause" id="btnPauseL">‚è∏</button>
      <button class="touch-btn" id="btnLeftL">‚óÑ</button>
      <button class="touch-btn" id="btnRightL">‚ñ∫</button>
    </div>

    <!-- Canvas with overlays -->
    <div class="canvas-frame" id="canvasFrame">
      <canvas id="gameCanvas" width="720" height="520"></canvas>

      <!-- START SCREEN -->
      <div class="overlay" id="startScreen">
        <div class="overlay-art">üêå</div>
        <div class="overlay-title">
          SNAILZ<br><span class="accent">INVADERS</span>
        </div>
        <div class="overlay-sub">
          DEFENDS LETTUCE ISLAND CONTRE LES ENVAHISSEURS.<br>CHOISIS TA FACTION.
        </div>
        <div class="faction-select" id="factionSelect">
          <button class="faction-btn selected" data-faction="aqua" onclick="selectFaction('aqua', this)">
            <span class="f-icon">üêå</span>AQUA
          </button>
          <button class="faction-btn" data-faction="magma" onclick="selectFaction('magma', this)">
            <span class="f-icon">üî•</span>MAGMA
          </button>
          <button class="faction-btn" data-faction="wizard" onclick="selectFaction('wizard', this)">
            <span class="f-icon">üßô</span>WIZARD
          </button>
          <button class="faction-btn" data-faction="chill" onclick="selectFaction('chill', this)">
            <span class="f-icon">üåø</span>CHILL
          </button>
        </div>
        <button class="start-game-btn" onclick="startGame()">‚ñ∫ JOUER</button>
      </div>

      <!-- PAUSE SCREEN -->
      <div class="overlay hidden" id="pauseScreen">
        <div class="overlay-title"><span class="aqua">PAUSE</span></div>
        <div class="pause-options">
          <button class="pause-btn primary" onclick="resumeGame()">REPRENDRE</button>
          <button class="pause-btn" onclick="quitToMenu()">MENU</button>
        </div>
      </div>

      <!-- GAME OVER SCREEN -->
      <div class="overlay hidden" id="gameOverScreen">
        <div class="overlay-title">GAME<br><span class="accent">OVER</span></div>
        <div class="go-score" id="goScore">0</div>
        <div class="new-record hidden" id="newRecord">‚òÖ NOUVEAU RECORD ‚òÖ</div>
        <div class="go-stats">
          <div class="go-stat">
            <div class="go-stat-val" id="goWave">0</div>
            <div class="go-stat-lbl">VAGUES</div>
          </div>
          <div class="go-stat">
            <div class="go-stat-val" id="goKills">0</div>
            <div class="go-stat-lbl">KILLS</div>
          </div>
          <div class="go-stat">
            <div class="go-stat-val" id="goCombo">0</div>
            <div class="go-stat-lbl">MAX COMBO</div>
          </div>
        </div>
        <button class="start-game-btn" onclick="startGame()">‚ñ∫ REJOUER</button>
        <button class="pause-btn" onclick="quitToMenu()" style="animation:slideUp 0.5s ease-out 0.4s both">MENU</button>
      </div>

      <!-- WAVE ANNOUNCEMENT -->
      <div class="overlay hidden" id="waveScreen">
        <div class="overlay-title" style="font-size:22px;color:var(--aqua)">VAGUE</div>
        <div class="go-score" id="waveNum" style="font-size:72px">1</div>
        <div class="overlay-sub" id="waveSubtext">LES ESCARGOTS APPROCHENT...</div>
      </div>
    </div>

    <!-- RIGHT PANEL ‚Äî landscape only (‚ú¶ SPECIAL + FIRE) -->
    <div class="touch-panel-right" id="touchPanelRight">
      <button class="touch-btn touch-special" id="btnSpecialR">‚ú¶</button>
      <button class="touch-btn touch-fire" id="btnFireR">FIRE</button>
    </div>

  </div><!-- /game-area -->

  <!-- Desktop controls hint -->
  <div class="controls-bar">
    <div class="ctrl-hint"><span class="key-badge">‚óÑ ‚ñ∫</span> DEPLACER</div>
    <div class="ctrl-hint"><span class="key-badge">ESPACE</span> TIRER</div>
    <div class="ctrl-hint"><span class="key-badge">P</span> PAUSE</div>
    <div class="ctrl-hint"><span class="key-badge">ESC</span> MENU</div>
  </div>

  <!-- Portrait touch controls (below canvas) -->
  <div class="touch-controls" id="touchControls">
    <div class="touch-dpad">
      <button class="touch-btn" id="btnLeft">‚óÑ</button>
      <button class="touch-btn" id="btnRight">‚ñ∫</button>
    </div>
    <button class="touch-btn touch-pause" id="btnPause">‚è∏</button>
    <div class="touch-action-group">
      <button class="touch-btn touch-special" id="btnSpecial">‚ú¶</button>
      <button class="touch-btn touch-fire" id="btnFire">FIRE</button>
    </div>
  </div>

</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê GAME ENGINE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<script>
// ===========================================
// SNAILZ INVADERS ‚Äî Full Game Engine
// ===========================================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// ‚îÄ‚îÄ FACTION CONFIG ‚îÄ‚îÄ
const FACTIONS = {
  aqua:   { color: '#00d4ff', glow: 'rgba(0,212,255,0.5)',  bullet: '#00d4ff', name: 'AQUA',   special: 'FREEZE' },
  magma:  { color: '#ff4500', glow: 'rgba(255,69,0,0.5)',   bullet: '#ff4500', name: 'MAGMA',  special: 'BLAST' },
  wizard: { color: '#a855f7', glow: 'rgba(168,85,247,0.5)', bullet: '#a855f7', name: 'WIZARD', special: 'PIERCE' },
  chill:  { color: '#39ff14', glow: 'rgba(57,255,20,0.5)',  bullet: '#39ff14', name: 'CHILL',  special: 'SHIELD' }
};

// ‚îÄ‚îÄ GAME STATE ‚îÄ‚îÄ
let G = {
  state: 'menu', // menu, playing, paused, gameover, waveintro
  faction: 'aqua',
  score: 0,
  lives: 3,
  wave: 1,
  combo: 0,
  maxCombo: 0,
  kills: 0,
  hiScore: parseInt(localStorage.getItem('snailzHiScore') || '0'),
  shakeTimer: 0,
  specialReady: false,
  specialTimer: 0,
  specialCooldown: 0,
  freezeTimer: 0,
};

// ‚îÄ‚îÄ PIXEL ART SPRITE SYSTEM ‚Äî offscreen canvas cache ‚îÄ‚îÄ
const _ENEMY_COLORS = {
  basic: { shell: '#8b0000', body: '#cc3333', glow: 'rgba(200,50,50,0.5)' },
  fast:  { shell: '#ff6600', body: '#ff9944', glow: 'rgba(255,120,0,0.5)' },
  tank:  { shell: '#444466', body: '#6666aa', glow: 'rgba(100,100,180,0.5)' },
  boss:  { shell: '#8b008b', body: '#cc44cc', glow: 'rgba(200,0,200,0.6)' },
};
const _SPRITE_STEPS = 24;   // quantization steps for smooth animation
const _spriteCache  = new Map();

// Internal renderer ‚Äî enemy snail into any context (used for pre-rendering)
function _renderEnemySnail(tc, x, y, size, type, wobble) {
  const p = size / 12;
  const c = _ENEMY_COLORS[type] || _ENEMY_COLORS.basic;
  tc.shadowColor = c.glow; tc.shadowBlur = 8;
  tc.fillStyle = c.body;
  tc.fillRect(x,       y + wobble,        12*p, 2*p);
  tc.fillRect(x + p,   y + 2*p + wobble, 10*p, 2*p);
  tc.fillStyle = '#ff0000'; tc.shadowColor = 'rgba(255,0,0,0.8)'; tc.shadowBlur = 6;
  tc.fillRect(x + 2*p, y + 2*p + wobble, 2*p, 2*p);
  tc.fillRect(x + 7*p, y + 2*p + wobble, 2*p, 2*p);
  tc.fillStyle = '#ffff00'; tc.shadowBlur = 0;
  tc.fillRect(x + 2.5*p, y + 2.5*p + wobble, p, p);
  tc.fillRect(x + 7.5*p, y + 2.5*p + wobble, p, p);
  tc.shadowColor = c.glow; tc.shadowBlur = 6;
  tc.fillStyle = c.shell;
  tc.fillRect(x + 2*p, y + 4*p + wobble, 8*p, 2*p);
  tc.fillRect(x + 3*p, y + 6*p + wobble, 6*p, 3*p);
  tc.fillRect(x + 4*p, y + 9*p + wobble, 4*p, 2*p);
  tc.fillStyle = shadeColor(c.shell, 25);
  tc.fillRect(x + 5*p, y + 5*p + wobble, 2*p, p);
  tc.fillRect(x + 4*p, y + 6*p + wobble, p, 2*p);
  tc.fillRect(x + 5*p, y + 7*p + wobble, 2*p, p);
  if (type === 'boss') {
    tc.fillStyle = '#ff00ff';
    tc.fillRect(x - p,     y + 4*p + wobble,  p, 3*p);
    tc.fillRect(x + 11*p,  y + 4*p + wobble,  p, 3*p);
    tc.fillRect(x + 5*p,   y + 10*p + wobble, 2*p, 2*p);
  }
}

// Internal renderer ‚Äî player snail into any context
function _renderPlayerSnail(tc, x, y, size, color, glow, t, eyeOpen) {
  const p = size / 12;
  tc.shadowColor = glow; tc.shadowBlur = 16;
  tc.fillStyle = color;
  tc.fillRect(x + 3*p, y,        6*p, 2*p);
  tc.fillRect(x + 2*p, y + 2*p, 8*p, 3*p);
  tc.fillRect(x + 3*p, y + 5*p, 6*p, 2*p);
  tc.fillRect(x + 4*p, y + 7*p, 4*p, p);
  tc.fillStyle = shadeColor(color, -40);
  tc.fillRect(x + 5*p, y + 2*p, 2*p, p);
  tc.fillRect(x + 4*p, y + 3*p, p, 2*p);
  tc.fillRect(x + 5*p, y + 4*p, 2*p, p);
  tc.fillStyle = shadeColor(color, 30); tc.shadowBlur = 4;
  tc.fillRect(x + p, y + 8*p, 10*p, 2*p);
  tc.fillRect(x,     y + 9*p, 12*p, 2*p);
  tc.fillStyle = '#ffffff';
  tc.fillRect(x + 2*p, y + 6*p, 2*p, 2*p);
  tc.fillRect(x + 7*p, y + 6*p, 2*p, 2*p);
  tc.fillStyle = '#000000'; tc.shadowBlur = 0;
  if (eyeOpen) {
    tc.fillRect(x + 2.5*p, y + 7*p, p, p);
    tc.fillRect(x + 7.5*p, y + 7*p, p, p);
  }
  const antL = Math.sin(t) * 2, antR = Math.cos(t) * 2;
  tc.strokeStyle = color; tc.lineWidth = 1;
  tc.beginPath(); tc.moveTo(x + 3*p, y + 6*p); tc.lineTo(x + 1.5*p, y + 3*p + antL); tc.stroke();
  tc.beginPath(); tc.moveTo(x + 8*p, y + 6*p); tc.lineTo(x + 9.5*p, y + 3*p + antR); tc.stroke();
  tc.fillStyle = color;
  tc.fillRect(x + p,   y + 2*p + antL, 1.5*p, 1.5*p);
  tc.fillRect(x + 9*p, y + 2*p + antR, 1.5*p, 1.5*p);
}

// Cache helpers
const _E_PAD = 14, _E_SZ = 36;
const _P_PAD = 20, _P_SZ = 48;
const _TAU   = 2 * Math.PI;

function _getEnemySprite(type, wobble) {
  const step = Math.round(((wobble + 1.5) / 3) * (_SPRITE_STEPS - 1));
  const key  = `e_${type}_${step}`;
  if (_spriteCache.has(key)) return _spriteCache.get(key);
  const oc = document.createElement('canvas');
  oc.width  = _E_SZ + _E_PAD * 2 + 6; // +6 for boss spikes
  oc.height = _E_SZ + _E_PAD * 2 + 6;
  _renderEnemySnail(oc.getContext('2d'), _E_PAD + 3, _E_PAD, _E_SZ, type,
                    Math.sin(step * (_TAU / _SPRITE_STEPS)) * 1.5);
  _spriteCache.set(key, oc);
  return oc;
}

function _getPlayerSprite(factionKey, frame) {
  const eyeOpen = !(frame % 200 < 6);
  const step    = Math.round(((frame * 0.1) % _TAU) / _TAU * _SPRITE_STEPS) % _SPRITE_STEPS;
  const key     = `p_${factionKey}_${step}_${eyeOpen ? 1 : 0}`;
  if (_spriteCache.has(key)) return _spriteCache.get(key);
  const oc = document.createElement('canvas');
  oc.width = oc.height = _P_SZ + _P_PAD * 2;
  const fc = FACTIONS[factionKey];
  _renderPlayerSnail(oc.getContext('2d'), _P_PAD, _P_PAD, _P_SZ,
                     fc.color, fc.glow, step * (_TAU / _SPRITE_STEPS), eyeOpen);
  _spriteCache.set(key, oc);
  return oc;
}

function drawPixelSnail(x, y, size, color, glow, isPlayer, frame) {
  if (isPlayer) {
    ctx.drawImage(_getPlayerSprite(G.faction, frame), x - _P_PAD, y - _P_PAD);
    return;
  }
  // Non-player fallback (direct render, not currently used in game)
  ctx.save();
  const p = size / 12, shellOffY = Math.sin(frame * 0.06) * 1.5;
  ctx.shadowColor = glow; ctx.shadowBlur = 8;
  ctx.fillStyle = color;
  ctx.fillRect(x + 3*p, y + shellOffY,        6*p, 2*p);
  ctx.fillRect(x + 2*p, y + 2*p + shellOffY, 8*p, 3*p);
  ctx.fillRect(x + 3*p, y + 5*p + shellOffY, 6*p, 2*p);
  ctx.fillRect(x + 4*p, y + 7*p + shellOffY, 4*p, p);
  ctx.fillStyle = shadeColor(color, -40);
  ctx.fillRect(x + 5*p, y + 2*p + shellOffY, 2*p, p);
  ctx.fillRect(x + 4*p, y + 3*p + shellOffY, p, 2*p);
  ctx.fillRect(x + 5*p, y + 4*p + shellOffY, 2*p, p);
  ctx.fillStyle = shadeColor(color, 30); ctx.shadowBlur = 4;
  ctx.fillRect(x + p, y + 8*p, 10*p, 2*p);
  ctx.fillRect(x,     y + 9*p, 12*p, 2*p);
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(x + 2*p, y + 6*p + shellOffY, 2*p, 2*p);
  ctx.fillRect(x + 7*p, y + 6*p + shellOffY, 2*p, 2*p);
  ctx.fillStyle = '#000000'; ctx.shadowBlur = 0;
  if (!(frame % 200 < 6)) {
    ctx.fillRect(x + 2.5*p, y + 7*p + shellOffY, p, p);
    ctx.fillRect(x + 7.5*p, y + 7*p + shellOffY, p, p);
  }
  ctx.restore();
}

function drawEnemySnail(x, y, size, type, frame) {
  const wobble = Math.sin(frame * 0.08 + x * 0.1) * 1.5;
  ctx.drawImage(_getEnemySprite(type, wobble), x - _E_PAD - 3, y - _E_PAD);
}

const _shadeCache = {};
function shadeColor(hex, percent) {
  const key = hex + percent;
  if (_shadeCache[key]) return _shadeCache[key];
  let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  r = Math.min(255, Math.max(0, r + percent));
  g = Math.min(255, Math.max(0, g + percent));
  b = Math.min(255, Math.max(0, b + percent));
  return (_shadeCache[key] = `rgb(${r},${g},${b})`);
}

// ‚îÄ‚îÄ ENTITIES ‚îÄ‚îÄ
let player = { x: 0, y: 0, w: 48, h: 48, speed: 5, cooldown: 0, invincible: 0 };
let bullets = [];
let enemies = [];
let enemyBullets = [];
let particles = [];
let powerups = [];
let stars = [];
let floatingTexts = [];
let frame = 0;

// ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'KeyP' && G.state === 'playing') pauseGame();
  else if (e.code === 'KeyP' && G.state === 'paused') resumeGame();
  else if (e.code === 'Escape') {
    if (G.state === 'playing') pauseGame();
    else if (G.state === 'paused') quitToMenu();
  }
  if (['Space','ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.code)) e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

// Touch controls ‚Äî bind portrait + landscape buttons
function setupTouch() {
  // Bind a button to a keys[] entry with visual feedback
  function bindKey(el, keyCode) {
    if (!el) return;
    const press   = e => { e.preventDefault(); keys[keyCode] = true;  el.classList.add('pressed'); };
    const release = e => { e.preventDefault(); keys[keyCode] = false; el.classList.remove('pressed'); };
    el.addEventListener('touchstart',  press,   { passive: false });
    el.addEventListener('touchend',    release, { passive: false });
    el.addEventListener('touchcancel', release);
    el.addEventListener('mousedown',  press);
    el.addEventListener('mouseup',    release);
    el.addEventListener('mouseleave', release);
  }

  function bindPause(el) {
    if (!el) return;
    const toggle = e => {
      e.preventDefault();
      if      (G.state === 'playing') pauseGame();
      else if (G.state === 'paused')  resumeGame();
    };
    el.addEventListener('touchstart', toggle, { passive: false });
    el.addEventListener('mousedown',  toggle);
  }

  // Portrait bar buttons
  bindKey(document.getElementById('btnLeft'),    'ArrowLeft');
  bindKey(document.getElementById('btnRight'),   'ArrowRight');
  bindKey(document.getElementById('btnFire'),    'Space');
  bindKey(document.getElementById('btnSpecial'), 'ShiftLeft');
  bindPause(document.getElementById('btnPause'));

  // Landscape panel buttons
  bindKey(document.getElementById('btnLeftL'),    'ArrowLeft');
  bindKey(document.getElementById('btnRightL'),   'ArrowRight');
  bindKey(document.getElementById('btnFireR'),    'Space');
  bindKey(document.getElementById('btnSpecialR'), 'ShiftLeft');
  bindPause(document.getElementById('btnPauseL'));
}
setupTouch();

// ‚îÄ‚îÄ STARFIELD ‚îÄ‚îÄ
function initStars() {
  stars = [];
  for (let i = 0; i < 80; i++) {
    stars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: Math.random() * 2 + 0.5,
      speed: Math.random() * 0.5 + 0.1,
      brightness: Math.random() * 0.5 + 0.3
    });
  }
}
initStars();

function updateStars() {
  stars.forEach(s => {
    s.y += s.speed;
    if (s.y > canvas.height) { s.y = 0; s.x = Math.random() * canvas.width; }
  });
}

function drawStars() {
  stars.forEach(s => {
    const flick = Math.sin(frame * 0.05 + s.x) * 0.15;
    ctx.fillStyle = `rgba(200,220,255,${s.brightness + flick})`;
    ctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.size, s.size);
  });
}

// ‚îÄ‚îÄ WAVE GENERATION ‚îÄ‚îÄ
function spawnWave(waveNum) {
  enemies = [];
  const rows = Math.min(3 + Math.floor(waveNum / 3), 6);
  const cols = Math.min(6 + Math.floor(waveNum / 2), 10);
  const size = 36;
  const padding = 10;
  const totalW = cols * (size + padding);
  const startX = (canvas.width - totalW) / 2;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let type = 'basic';
      if (r === 0 && waveNum >= 3) type = 'tank';
      if (r === 0 && c === Math.floor(cols/2) && waveNum >= 5 && waveNum % 5 === 0) type = 'boss';
      if (r >= rows - 1 && waveNum >= 2) type = 'fast';

      const hp = type === 'boss' ? 8 + waveNum : type === 'tank' ? 3 : type === 'fast' ? 1 : 2;
      const pts = type === 'boss' ? 500 : type === 'tank' ? 150 : type === 'fast' ? 75 : 100;

      enemies.push({
        x: startX + c * (size + padding),
        y: -60 - r * (size + padding),  // start above screen
        targetY: 40 + r * (size + padding),
        w: size, h: size,
        type, hp, maxHp: hp, pts,
        alive: true,
        shootTimer: Math.random() * 200 + 100,
        entering: true,
        enterDelay: (r * cols + c) * 3,
        enterFrame: 0,
      });
    }
  }
}

// ‚îÄ‚îÄ SPAWN POWERUP ‚îÄ‚îÄ
function spawnPowerup(x, y) {
  if (Math.random() > 0.15) return;
  const types = ['rapid', 'shield', 'bomb', 'multi'];
  const type = types[Math.floor(Math.random() * types.length)];
  const icons = { rapid: '‚ö°', shield: 'üõ°Ô∏è', bomb: 'üí£', multi: '‚ú¶' };
  const colors = { rapid: '#ffd700', shield: '#39ff14', bomb: '#ff4500', multi: '#a855f7' };
  powerups.push({ x, y, w: 20, h: 20, type, icon: icons[type], color: colors[type], vy: 1.5 });
}

// ‚îÄ‚îÄ PARTICLES ‚îÄ‚îÄ
function spawnExplosion(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
    const speed = Math.random() * 3 + 1;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 30 + Math.random() * 20,
      maxLife: 50,
      size: Math.random() * 4 + 2,
      color,
    });
  }
}

function spawnFloatingText(x, y, text, color) {
  floatingTexts.push({ x, y, text, color, life: 40, vy: -1.5 });
}

// ‚îÄ‚îÄ FACTION SELECT ‚îÄ‚îÄ
function selectFaction(faction, btn) {
  G.faction = faction;
  document.querySelectorAll('.faction-btn').forEach(b => b.classList.remove('selected'));
  btn.classList.add('selected');
  document.getElementById('navFaction').textContent = FACTIONS[faction].name;
  document.getElementById('navFaction').style.color = FACTIONS[faction].color;
  document.getElementById('navFaction').style.borderColor = FACTIONS[faction].color;
}

// ‚îÄ‚îÄ GAME FLOW ‚îÄ‚îÄ
function startGame() {
  G.state = 'waveintro';
  G.score = 0;
  G.lives = 3;
  G.wave = 1;
  G.combo = 0;
  G.maxCombo = 0;
  G.kills = 0;
  G.freezeTimer = 0;
  G.specialCooldown = 0;
  bullets = [];
  enemyBullets = [];
  particles = [];
  powerups = [];
  floatingTexts = [];

  player.x = canvas.width / 2 - player.w / 2;
  player.y = canvas.height - 60;
  player.invincible = 0;
  player.cooldown = 0;
  player.rapidFire = 0;
  player.multiShot = 0;
  player.shieldActive = 0;

  updateHUD();
  showScreen('waveScreen');
  showWaveIntro(1);
}

function showWaveIntro(waveNum) {
  document.getElementById('waveNum').textContent = waveNum;
  const subs = [
    'LES ESCARGOTS APPROCHENT...',
    'ILS SONT PLUS FORTS CETTE FOIS !',
    'ATTENTION AUX TANKS !',
    'LA HORDE S\'INTENSIFIE !',
    'LE BOSS APPROCHE...',
  ];
  document.getElementById('waveSubtext').textContent = subs[Math.min(waveNum - 1, subs.length - 1)];

  setTimeout(() => {
    hideAllScreens();
    G.state = 'playing';
    spawnWave(waveNum);
  }, 1800);
}

function pauseGame() {
  G.state = 'paused';
  showScreen('pauseScreen');
}

function resumeGame() {
  G.state = 'playing';
  hideAllScreens();
  requestAnimationFrame(gameLoop);
}

// ‚îÄ‚îÄ Game-over screen refs ‚îÄ‚îÄ
const _elNavHi    = document.getElementById('navHiScore');
const _elGoScore  = document.getElementById('goScore');
const _elGoWave   = document.getElementById('goWave');
const _elGoKills  = document.getElementById('goKills');
const _elGoCombo  = document.getElementById('goCombo');
const _elNewRec   = document.getElementById('newRecord');

function gameOver() {
  G.state = 'gameover';
  if (G.score > G.hiScore) {
    G.hiScore = G.score;
    localStorage.setItem('snailzHiScore', G.hiScore);
    _elNewRec.classList.remove('hidden');
  } else {
    _elNewRec.classList.add('hidden');
  }
  _elNavHi.textContent   = String(G.hiScore).padStart(5, '0');
  _elGoScore.textContent = G.score;
  _elGoWave.textContent  = G.wave;
  _elGoKills.textContent = G.kills;
  _elGoCombo.textContent = G.maxCombo;
  showScreen('gameOverScreen');
}

function quitToMenu() {
  G.state = 'menu';
  showScreen('startScreen');
}

function showScreen(id) {
  hideAllScreens();
  document.getElementById(id).classList.remove('hidden');
}

function hideAllScreens() {
  document.querySelectorAll('.overlay').forEach(o => o.classList.add('hidden'));
}

// ‚îÄ‚îÄ HUD ‚Äî refs cach√©es ‚îÄ‚îÄ
const _hudScore = document.getElementById('hudScore');
const _hudLives = document.getElementById('hudLives');
const _hudWave  = document.getElementById('hudWave');
const _hudCombo = document.getElementById('hudCombo');

function updateHUD() {
  _hudScore.textContent = String(G.score).padStart(5, '0');
  _hudLives.textContent = '‚ô•'.repeat(Math.max(0, G.lives)) + '‚ô°'.repeat(Math.max(0, 3 - G.lives));
  _hudWave.textContent  = String(G.wave).padStart(2, '0');
  _hudCombo.textContent = 'x' + G.combo;
}

// ‚îÄ‚îÄ UPDATE LOGIC ‚îÄ‚îÄ
function update() {
  if (G.state !== 'playing') return;
  frame++;

  // Freeze effect
  const speedMult = G.freezeTimer > 0 ? 0.3 : 1;
  if (G.freezeTimer > 0) G.freezeTimer--;

  // Player movement
  if (keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed;
  if (keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;
  player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));

  // Timers
  if (player.cooldown > 0) player.cooldown--;
  if (player.invincible > 0) player.invincible--;
  if (player.rapidFire > 0) player.rapidFire--;
  if (player.multiShot > 0) player.multiShot--;
  if (player.shieldActive > 0) player.shieldActive--;
  if (G.specialCooldown > 0) G.specialCooldown--;

  // Shooting
  const fireRate = player.rapidFire > 0 ? 5 : 12;
  if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.cooldown <= 0) {
    const fc = FACTIONS[G.faction];
    bullets.push({
      x: player.x + player.w / 2 - 2,
      y: player.y - 4,
      w: 4, h: 10, vy: -8,
      color: fc.bullet,
      glow: fc.glow,
      pierce: G.faction === 'wizard' ? 1 : 0,
    });
    if (player.multiShot > 0) {
      bullets.push({ x: player.x + 4, y: player.y, w: 3, h: 8, vy: -7, vx: -1.5, color: fc.bullet, glow: fc.glow, pierce: 0 });
      bullets.push({ x: player.x + player.w - 7, y: player.y, w: 3, h: 8, vy: -7, vx: 1.5, color: fc.bullet, glow: fc.glow, pierce: 0 });
    }
    player.cooldown = fireRate;
  }

  // Special ability (Shift key)
  if ((keys['ShiftLeft'] || keys['ShiftRight']) && G.specialCooldown <= 0) {
    activateSpecial();
    G.specialCooldown = 600; // 10 seconds
  }

  // Update bullets
  bullets = bullets.filter(b => {
    b.y += b.vy;
    if (b.vx) b.x += b.vx;
    return b.y > -20 && b.x > -20 && b.x < canvas.width + 20;
  });

  // Update enemies
  let allEntered = true;
  const aliveEnemies = enemies.filter(e => e.alive);

  aliveEnemies.forEach(e => {
    // Entry animation
    if (e.entering) {
      e.enterFrame++;
      if (e.enterFrame > e.enterDelay) {
        e.y += (e.targetY - e.y) * 0.08;
        if (Math.abs(e.y - e.targetY) < 1) {
          e.y = e.targetY;
          e.entering = false;
        }
      }
      allEntered = false;
      return;
    }

    // Horizontal movement
    e.x += (Math.sin(frame * 0.015 + e.targetY * 0.1) * 1.2) * speedMult;

    // Slow descent
    e.y += 0.03 * G.wave * speedMult;

    // Shooting
    e.shootTimer -= speedMult;
    if (e.shootTimer <= 0) {
      e.shootTimer = Math.max(60, 200 - G.wave * 15) + Math.random() * 100;
      if (Math.random() < 0.3 + G.wave * 0.03) {
        enemyBullets.push({
          x: e.x + e.w / 2 - 2, y: e.y + e.h,
          w: 4, h: 6, vy: 2.5 + G.wave * 0.2,
          color: '#ff3333'
        });
      }
    }

    // Reached bottom
    if (e.y > canvas.height - 80) {
      G.lives--;
      G.shakeTimer = 15;
      e.alive = false;
      spawnExplosion(e.x + e.w/2, e.y + e.h/2, '#ff0000', 8);
      updateHUD();
      if (G.lives <= 0) gameOver();
    }
  });

  // Enemy bullets
  enemyBullets = enemyBullets.filter(b => {
    b.y += b.vy * speedMult;
    return b.y < canvas.height + 20;
  });

  // Collision: player bullets ‚Üí enemies
  bullets.forEach((b, bi) => {
    aliveEnemies.forEach(e => {
      if (!e.alive || e.entering) return;
      if (b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
        e.hp--;
        if (b.pierce <= 0) bullets[bi] = null;
        else b.pierce--;

        if (e.hp <= 0) {
          e.alive = false;
          G.score += e.pts * (1 + Math.floor(G.combo / 5));
          G.combo++;
          G.kills++;
          if (G.combo > G.maxCombo) G.maxCombo = G.combo;
          spawnExplosion(e.x + e.w/2, e.y + e.h/2, FACTIONS[G.faction].color, 12);
          spawnFloatingText(e.x + e.w/2, e.y, '+' + (e.pts * (1 + Math.floor(G.combo / 5))), FACTIONS[G.faction].color);
          spawnPowerup(e.x + e.w/2, e.y + e.h/2);
          updateHUD();
        } else {
          spawnExplosion(b.x, b.y, '#ffffff', 4);
        }
      }
    });
  });
  bullets = bullets.filter(b => b !== null);

  // Collision: enemy bullets ‚Üí player
  if (player.invincible <= 0) {
    enemyBullets.forEach((b, bi) => {
      if (b.x < player.x + player.w && b.x + b.w > player.x && b.y < player.y + player.h && b.y + b.h > player.y) {
        if (player.shieldActive > 0) {
          player.shieldActive = 0;
          spawnExplosion(player.x + player.w/2, player.y, '#39ff14', 8);
          enemyBullets[bi] = null;
        } else {
          G.lives--;
          G.combo = 0;
          G.shakeTimer = 20;
          player.invincible = 120;
          spawnExplosion(player.x + player.w/2, player.y + player.h/2, '#ff0000', 16);
          updateHUD();
          if (G.lives <= 0) gameOver();
          enemyBullets[bi] = null;
        }
      }
    });
    enemyBullets = enemyBullets.filter(b => b !== null);
  }

  // Collision: powerups ‚Üí player
  powerups = powerups.filter(p => {
    p.y += p.vy;
    if (p.x - 10 < player.x + player.w && p.x + p.w + 10 > player.x && p.y < player.y + player.h && p.y + p.h > player.y) {
      applyPowerup(p.type);
      spawnFloatingText(p.x, p.y, p.type.toUpperCase() + '!', p.color);
      spawnExplosion(p.x, p.y, p.color, 6);
      return false;
    }
    return p.y < canvas.height + 20;
  });

  // Particles
  particles = particles.filter(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.05;
    p.life--;
    return p.life > 0;
  });

  // Floating texts
  floatingTexts = floatingTexts.filter(f => {
    f.y += f.vy;
    f.life--;
    return f.life > 0;
  });

  // Screen shake decay
  if (G.shakeTimer > 0) G.shakeTimer--;

  // Wave complete?
  if (aliveEnemies.length === 0 && !enemies.some(e => e.entering)) {
    G.wave++;
    G.state = 'waveintro';
    showScreen('waveScreen');
    showWaveIntro(G.wave);
  }

  updateStars();
}

// ‚îÄ‚îÄ SPECIAL ABILITIES ‚îÄ‚îÄ
function activateSpecial() {
  const fc = G.faction;
  switch(fc) {
    case 'aqua': // Freeze all enemies
      G.freezeTimer = 180;
      spawnFloatingText(canvas.width/2, canvas.height/2, 'FREEZE!', '#00d4ff');
      break;
    case 'magma': // Explosion ‚Äî damage all enemies
      enemies.filter(e => e.alive).forEach(e => {
        e.hp -= 2;
        if (e.hp <= 0) {
          e.alive = false;
          G.score += e.pts;
          G.kills++;
          spawnExplosion(e.x + e.w/2, e.y + e.h/2, '#ff4500', 8);
        }
      });
      spawnFloatingText(canvas.width/2, canvas.height/2, 'BLAST!', '#ff4500');
      G.shakeTimer = 25;
      break;
    case 'wizard': // All bullets become piercing for a while
      bullets.forEach(b => b.pierce = 5);
      spawnFloatingText(canvas.width/2, canvas.height/2, 'PIERCE!', '#a855f7');
      break;
    case 'chill': // Shield
      player.shieldActive = 300;
      spawnFloatingText(canvas.width/2, canvas.height/2, 'SHIELD!', '#39ff14');
      break;
  }
}

function applyPowerup(type) {
  switch(type) {
    case 'rapid': player.rapidFire = 300; break;
    case 'shield': player.shieldActive = 300; break;
    case 'bomb':
      enemies.filter(e => e.alive && !e.entering).forEach(e => {
        e.hp -= 3;
        if (e.hp <= 0) {
          e.alive = false;
          G.score += e.pts;
          G.kills++;
          spawnExplosion(e.x + e.w/2, e.y + e.h/2, '#ff4500', 10);
        }
      });
      G.shakeTimer = 20;
      break;
    case 'multi': player.multiShot = 300; break;
  }
  updateHUD();
}

// ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Apply screen shake
  if (G.shakeTimer > 0) {
    ctx.save();
    ctx.translate(
      (Math.random() - 0.5) * G.shakeTimer * 0.8,
      (Math.random() - 0.5) * G.shakeTimer * 0.8
    );
  }

  // Background
  ctx.fillStyle = '#03040a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Stars
  drawStars();

  // Freeze overlay
  if (G.freezeTimer > 0) {
    ctx.fillStyle = `rgba(0,212,255,${0.05 + Math.sin(frame * 0.1) * 0.02})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // Powerups
  powerups.forEach(p => {
    ctx.save();
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 12;
    ctx.font = '16px serif';
    ctx.textAlign = 'center';
    ctx.fillText(p.icon, p.x + 10, p.y + 16);
    ctx.restore();
  });

  // Enemy bullets
  enemyBullets.forEach(b => {
    ctx.save();
    ctx.shadowColor = 'rgba(255,0,0,0.8)';
    ctx.shadowBlur = 8;
    ctx.fillStyle = b.color;
    ctx.fillRect(b.x, b.y, b.w, b.h);
    // Trail
    ctx.fillStyle = 'rgba(255,50,50,0.3)';
    ctx.fillRect(b.x + 1, b.y - 4, 2, 4);
    ctx.restore();
  });

  // Enemies
  enemies.filter(e => e.alive).forEach(e => {
    drawEnemySnail(e.x, e.y, e.w, e.type, frame);

    // HP bar for tanks/bosses
    if (e.maxHp > 2 && e.hp < e.maxHp) {
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fillRect(e.x, e.y - 6, e.w, 3);
      ctx.fillStyle = e.type === 'boss' ? '#ff00ff' : '#ff6666';
      ctx.fillRect(e.x, e.y - 6, e.w * (e.hp / e.maxHp), 3);
    }
  });

  // Player bullets
  bullets.forEach(b => {
    ctx.save();
    ctx.shadowColor = b.glow;
    ctx.shadowBlur = 10;
    ctx.fillStyle = b.color;
    ctx.fillRect(b.x, b.y, b.w, b.h);
    // Trail
    ctx.fillStyle = b.glow;
    ctx.globalAlpha = 0.3;
    ctx.fillRect(b.x + 1, b.y + b.h, 2, 8);
    ctx.globalAlpha = 1;
    ctx.restore();
  });

  // Player
  if (G.state === 'playing' || G.state === 'paused') {
    if (player.invincible <= 0 || frame % 6 < 3) {
      const fc = FACTIONS[G.faction];
      drawPixelSnail(player.x, player.y, player.w, fc.color, fc.glow, true, frame);

      // Shield visual
      if (player.shieldActive > 0) {
        ctx.save();
        ctx.strokeStyle = player.shieldActive < 60 ? `rgba(57,255,20,${0.3 + Math.sin(frame * 0.3) * 0.3})` : 'rgba(57,255,20,0.5)';
        ctx.lineWidth = 2;
        ctx.shadowColor = 'rgba(57,255,20,0.5)';
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(player.x + player.w/2, player.y + player.h/2, player.w * 0.7, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  // Particles
  particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 4;
    ctx.fillRect(p.x, p.y, p.size, p.size);
    ctx.restore();
  });

  // Floating texts
  floatingTexts.forEach(f => {
    ctx.save();
    ctx.globalAlpha = f.life / 40;
    ctx.font = '10px "Press Start 2P"';
    ctx.fillStyle = f.color;
    ctx.shadowColor = f.color;
    ctx.shadowBlur = 8;
    ctx.textAlign = 'center';
    ctx.fillText(f.text, f.x, f.y);
    ctx.restore();
  });

  // Special cooldown indicator
  if (G.state === 'playing' && G.specialCooldown > 0) {
    const pct = 1 - G.specialCooldown / 600;
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(10, canvas.height - 14, 80, 6);
    ctx.fillStyle = FACTIONS[G.faction].color;
    ctx.fillRect(10, canvas.height - 14, 80 * pct, 6);
    ctx.font = '6px "Press Start 2P"';
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.textAlign = 'left';
    ctx.fillText('SPECIAL [SHIFT]', 10, canvas.height - 18);
  } else if (G.state === 'playing') {
    ctx.font = '6px "Press Start 2P"';
    ctx.fillStyle = FACTIONS[G.faction].color;
    ctx.shadowColor = FACTIONS[G.faction].glow;
    ctx.shadowBlur = 6;
    ctx.textAlign = 'left';
    ctx.fillText('‚ñ∂ SPECIAL READY [SHIFT]', 10, canvas.height - 14);
    ctx.shadowBlur = 0;
  }

  if (G.shakeTimer > 0) ctx.restore();
}

// ‚îÄ‚îÄ GAME LOOP ‚îÄ‚îÄ
function gameLoop() {
  update();
  draw();
  if (G.state !== 'gameover' && G.state !== 'menu') {
    requestAnimationFrame(gameLoop);
  } else {
    drawMenuBg();
  }
}

function drawMenuBg() {
  updateStars();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#03040a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  drawStars();
  requestAnimationFrame(drawMenuBg);
}

// ‚îÄ‚îÄ INIT ‚îÄ‚îÄ
document.getElementById('navHiScore').textContent = String(G.hiScore).padStart(5, '0');

// Detect real touch device
function isTouchDevice() {
  return navigator.maxTouchPoints > 0 || 'ontouchstart' in window;
}

// Resize canvas to fit available space, accounting for layout
function resizeCanvas() {
  const touch     = isTouchDevice();
  const landscape = window.innerWidth > window.innerHeight;
  const W = window.innerWidth, H = window.innerHeight;
  let maxW;

  if (touch && landscape && H <= 540) {
    // === LANDSCAPE MOBILE ===
    // Left panel (86px) + canvas + right panel (86px)
    // Slim nav (40px) + compact HUD (~32px) + gap (6px)
    const panelW = 86 * 2;
    const navH   = 40, hudH = 32, gapH = 6;
    const availW = W - panelW;
    const availH = H - navH - hudH - gapH;
    // Constrain by both width and height (maintain 720:520 ratio)
    const byW = availW;
    const byH = availH * (720 / 520);
    maxW = Math.floor(Math.min(byW, byH));
  } else if (touch && !landscape) {
    // === PORTRAIT MOBILE ===
    // Nav (56) + HUD (50) + touch controls (82) + gaps (20)
    const navH = 56, hudH = 50, ctrlH = 82, gapH = 20;
    const byW = Math.min(720, W - 16 * 2);
    const byH = (H - navH - hudH - ctrlH - gapH) * (720 / 520);
    maxW = Math.floor(Math.min(byW, byH));
  } else {
    // === DESKTOP ===
    maxW = Math.min(720, W - 80);
  }

  maxW = Math.max(200, maxW);
  canvas.style.width  = maxW + 'px';
  canvas.style.height = Math.floor(maxW * (520 / 720)) + 'px';
}

// Show/hide portrait overlay & update layout on orientation change
function updateOrientation() {
  const touch    = isTouchDevice();
  const portrait = window.innerWidth < window.innerHeight;
  const overlay  = document.getElementById('portraitOverlay');

  if (touch && portrait && window.innerWidth < 768) {
    // Show rotate overlay on portrait phones (not tablets)
    overlay.classList.add('active');
    if (G.state === 'playing') pauseGame();
  } else {
    overlay.classList.remove('active');
  }

  resizeCanvas();
}

window.addEventListener('resize', updateOrientation);
window.addEventListener('orientationchange', () => setTimeout(updateOrientation, 250));
updateOrientation();

// Start ambient loop
drawMenuBg();
</script>
</body>
</html>
