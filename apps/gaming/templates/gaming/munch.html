{% extends "core/base.html" %}
{% load static %}

{% block title %}Snailz Munch — CHILLING SNAILZ{% endblock %}

{% block extra_css %}
<style>
#munch-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
  padding-top: 100px;
  min-height: 100vh;
  background: var(--deep);
  padding-bottom: 60px;
}
.munch-head {
  text-align: center;
  margin-bottom: 8px;
}
.munch-hud {
  display: flex;
  gap: 48px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 13px;
  color: var(--muted);
  letter-spacing: .08em;
}
.munch-hud span { color: var(--aqua); font-size: 18px; font-weight: 700; }
#munch-canvas {
  display: block;
  border: 2px solid var(--border);
  background: #060a0f;
  image-rendering: pixelated;
  box-shadow: 0 0 40px rgba(0, 212, 255, .08);
}
#munch-overlay {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
  background: rgba(6, 10, 15, .92);
  border: 1px solid var(--border);
}
.munch-canvas-wrap {
  position: relative;
  line-height: 0;
}
.munch-overlay-title {
  font-family: 'Press Start 2P', monospace;
  font-size: 14px;
  color: var(--aqua);
  text-align: center;
  line-height: 1.8;
}
.munch-overlay-sub {
  font-family: 'JetBrains Mono', monospace;
  font-size: 12px;
  color: var(--muted);
  text-align: center;
}
.munch-overlay-score {
  font-family: 'JetBrains Mono', monospace;
  font-size: 15px;
  color: var(--fg);
}
.munch-controls {
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  color: var(--muted);
  text-align: center;
  line-height: 2;
}
kbd {
  display: inline-block;
  border: 1px solid var(--border);
  padding: 1px 6px;
  font-family: inherit;
  font-size: 10px;
  color: var(--fg);
  background: var(--void);
  border-radius: 2px;
}
.back-link {
  font-family: 'JetBrains Mono', monospace;
  font-size: 12px;
  color: var(--muted);
  text-decoration: none;
  border-bottom: 1px solid transparent;
}
.back-link:hover { color: var(--aqua); border-color: var(--aqua); }
</style>
{% endblock %}

{% block content %}
<div id="munch-wrapper">

  <div class="munch-head reveal">
    <p class="tag">LETTUCE ISLAND ARCADE</p>
    <h2 class="section-title" style="color:var(--aqua)">Snailz Munch</h2>
  </div>

  <div class="munch-hud">
    <div>SCORE <span id="hud-score">0</span></div>
    <div>BEST <span id="hud-best">0</span></div>
    <div>LEVEL <span id="hud-level">1</span></div>
  </div>

  <div class="munch-canvas-wrap">
    <canvas id="munch-canvas" width="480" height="480"></canvas>
    <div id="munch-overlay" style="width:480px;height:480px;top:0;left:0">
      <p class="munch-overlay-title" id="overlay-title">SNAILZ MUNCH</p>
      <p class="munch-overlay-sub" id="overlay-sub">Mange les laitues, evite les murs.</p>
      <p class="munch-overlay-score" id="overlay-score" style="display:none"></p>
      <button class="btn-primary" id="start-btn" style="font-size:12px;padding:12px 32px">JOUER</button>
    </div>
  </div>

  <div class="munch-controls">
    <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> &nbsp;ou&nbsp; <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd>
    &nbsp;·&nbsp; <kbd>P</kbd> pause
  </div>

  <a href="{% url 'gaming:index' %}" class="back-link">← retour à l'arcade</a>

</div>

<script>
(function () {
  const CELL = 20;
  const COLS = 24;
  const ROWS = 24;
  const W = COLS * CELL;  // 480
  const H = ROWS * CELL;  // 480

  // Palette from site CSS vars (approximated)
  const C = {
    bg:     '#060a0f',
    grid:   '#0c1219',
    head:   '#00d4ff',
    body:   '#0095b3',
    tail:   '#006680',
    food:   '#39ff14',   // neon green for lettuce
    wall:   '#1a2332',
    text:   '#e8edf2',
    muted:  '#6b7a8d',
    danger: '#ff3860',
  };

  const canvas = document.getElementById('munch-canvas');
  const ctx    = canvas.getContext('2d');
  const overlay     = document.getElementById('munch-overlay');
  const startBtn    = document.getElementById('start-btn');
  const hudScore    = document.getElementById('hud-score');
  const hudBest     = document.getElementById('hud-best');
  const hudLevel    = document.getElementById('hud-level');
  const overlayTitle = document.getElementById('overlay-title');
  const overlaySub   = document.getElementById('overlay-sub');
  const overlayScore = document.getElementById('overlay-score');

  let snake, dir, nextDir, food, score, best, level, speed, paused, running, raf;

  best = parseInt(localStorage.getItem('munch-best') || '0');
  hudBest.textContent = best;

  function init() {
    const mid = Math.floor(COLS / 2);
    snake = [
      { x: mid,     y: 12 },
      { x: mid - 1, y: 12 },
      { x: mid - 2, y: 12 },
    ];
    dir      = { x: 1, y: 0 };
    nextDir  = { x: 1, y: 0 };
    score    = 0;
    level    = 1;
    speed    = 140; // ms per tick
    paused   = false;
    running  = true;
    hudScore.textContent = 0;
    hudLevel.textContent = 1;
    placeFood();
  }

  function placeFood() {
    let pos;
    do {
      pos = { x: Math.floor(Math.random() * COLS), y: Math.floor(Math.random() * ROWS) };
    } while (snake.some(s => s.x === pos.x && s.y === pos.y));
    food = pos;
  }

  // ── Game loop (tick-based) ──────────────────────────────────────────────────
  let lastTick = 0;
  function loop(ts) {
    raf = requestAnimationFrame(loop);
    if (paused || !running) return;
    if (ts - lastTick < speed) { draw(); return; }
    lastTick = ts;
    tick();
    draw();
  }

  function tick() {
    dir = { ...nextDir };
    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

    // Wall collision
    if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
      return gameOver();
    }
    // Self collision
    if (snake.some(s => s.x === head.x && s.y === head.y)) {
      return gameOver();
    }

    snake.unshift(head);

    if (head.x === food.x && head.y === food.y) {
      score += 10 * level;
      hudScore.textContent = score;
      if (score > best) {
        best = score;
        hudBest.textContent = best;
        localStorage.setItem('munch-best', best);
      }
      // Level up every 5 fruits
      if (snake.length % 5 === 0) {
        level = Math.min(level + 1, 10);
        speed = Math.max(60, 140 - (level - 1) * 12);
        hudLevel.textContent = level;
      }
      placeFood();
    } else {
      snake.pop();
    }
  }

  // ── Drawing ─────────────────────────────────────────────────────────────────
  function draw() {
    ctx.fillStyle = C.bg;
    ctx.fillRect(0, 0, W, H);

    // Grid dots
    ctx.fillStyle = C.grid;
    for (let x = 0; x < COLS; x++) {
      for (let y = 0; y < ROWS; y++) {
        ctx.fillRect(x * CELL + CELL / 2 - 1, y * CELL + CELL / 2 - 1, 2, 2);
      }
    }

    // Food (lettuce — pixelated leaf shape)
    drawLettuce(food.x, food.y);

    // Snake
    snake.forEach((seg, i) => {
      const t = i / (snake.length - 1 || 1);
      ctx.fillStyle = i === 0 ? C.head : lerpColor(C.body, C.tail, t);
      const pad = i === 0 ? 1 : 2;
      ctx.fillRect(seg.x * CELL + pad, seg.y * CELL + pad, CELL - pad * 2, CELL - pad * 2);

      // Eyes on head
      if (i === 0) {
        ctx.fillStyle = C.bg;
        const ex = dir.x === 1 ? 13 : dir.x === -1 ? 4 : 6;
        const ey = dir.y === 1 ? 13 : dir.y === -1 ? 4 : 6;
        const ex2 = dir.y !== 0 ? ex + 8 : ex;
        const ey2 = dir.x !== 0 ? ey + 8 : ey;
        ctx.fillRect(seg.x * CELL + ex,  seg.y * CELL + ey,  3, 3);
        ctx.fillRect(seg.x * CELL + ex2, seg.y * CELL + ey2, 3, 3);
      }
    });
  }

  function drawLettuce(gx, gy) {
    const x = gx * CELL, y = gy * CELL;
    // Simple pixel leaf
    ctx.fillStyle = C.food;
    ctx.fillRect(x + 6,  y + 4,  8, 2);
    ctx.fillRect(x + 4,  y + 6,  12, 4);
    ctx.fillRect(x + 4,  y + 10, 12, 4);
    ctx.fillRect(x + 6,  y + 14, 8, 2);
    // shine
    ctx.fillStyle = '#7fff6e';
    ctx.fillRect(x + 8, y + 6, 2, 2);
  }

  // Lerp between two hex colours
  function lerpColor(a, b, t) {
    const ah = parseInt(a.slice(1), 16);
    const bh = parseInt(b.slice(1), 16);
    const ar = (ah >> 16) & 0xff, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
    const br = (bh >> 16) & 0xff, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
    const r = Math.round(ar + (br - ar) * t);
    const g = Math.round(ag + (bg - ag) * t);
    const bl2 = Math.round(ab + (bb - ab) * t);
    return `rgb(${r},${g},${bl2})`;
  }

  // ── Game over ───────────────────────────────────────────────────────────────
  function gameOver() {
    running = false;
    cancelAnimationFrame(raf);

    // Flash red
    let flashes = 0;
    const flash = setInterval(() => {
      ctx.fillStyle = `rgba(255,56,96,${flashes % 2 === 0 ? .18 : 0})`;
      ctx.fillRect(0, 0, W, H);
      if (++flashes >= 6) {
        clearInterval(flash);
        showOverlay('GAME OVER', score > 0 ? `SCORE : ${score}` : '', 'REJOUER');
      }
    }, 80);
  }

  function showOverlay(title, scoreText, btnLabel) {
    overlayTitle.textContent = title;
    overlaySub.textContent   = '';
    if (scoreText) {
      overlayScore.style.display = 'block';
      overlayScore.textContent   = scoreText;
    } else {
      overlayScore.style.display = 'none';
      overlaySub.textContent     = 'Mange les laitues, evite les murs.';
    }
    startBtn.textContent = btnLabel;
    overlay.style.display = 'flex';
  }

  // ── Controls ─────────────────────────────────────────────────────────────────
  document.addEventListener('keydown', e => {
    const map = {
      ArrowUp: { x: 0, y: -1 }, w: { x: 0, y: -1 }, W: { x: 0, y: -1 },
      ArrowDown:  { x: 0, y: 1 }, s: { x: 0, y: 1 }, S: { x: 0, y: 1 },
      ArrowLeft:  { x: -1, y: 0 }, a: { x: -1, y: 0 }, A: { x: -1, y: 0 },
      ArrowRight: { x: 1, y: 0 }, d: { x: 1, y: 0 }, D: { x: 1, y: 0 },
    };
    if (map[e.key]) {
      const nd = map[e.key];
      // Prevent reversing
      if (nd.x !== -dir.x || nd.y !== -dir.y) nextDir = nd;
      e.preventDefault();
    }
    if ((e.key === 'p' || e.key === 'P') && running) {
      paused = !paused;
    }
  });

  // Mobile swipe support
  let touchStart = null;
  canvas.addEventListener('touchstart', e => { touchStart = e.touches[0]; }, { passive: true });
  canvas.addEventListener('touchend', e => {
    if (!touchStart) return;
    const dx = e.changedTouches[0].clientX - touchStart.clientX;
    const dy = e.changedTouches[0].clientY - touchStart.clientY;
    if (Math.abs(dx) > Math.abs(dy)) {
      const nd = dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 };
      if (nd.x !== -dir.x) nextDir = nd;
    } else {
      const nd = dy > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 };
      if (nd.y !== -dir.y) nextDir = nd;
    }
    touchStart = null;
  }, { passive: true });

  startBtn.addEventListener('click', () => {
    overlay.style.display = 'none';
    init();
    lastTick = 0;
    raf = requestAnimationFrame(loop);
    canvas.focus();
  });

  // Initial draw
  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, W, H);
})();
</script>
{% endblock %}
